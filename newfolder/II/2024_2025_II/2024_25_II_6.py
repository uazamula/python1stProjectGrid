# F. Красивий рядок
# Бінарний рядок — це рядок, який містить лише "0" та "1".
#
# Підрядок рядка — це рядок, який можна отримати, видаливши певну кількість символів з початку та/або кінця.
#
# Сакурако вважає бінарний рядок красивим, якщо кількість одиниць щонайменше 2 і це число ділить довжину рядка.
#
# Наприклад, "1001", "011100" та "010100100" є красивими рядками, але рядки "101", "01010" та "1001000" не є красивими.
#
# Сакурако любить красиві рядки, але їй погано вдається їх шукати. Тому вона просить вас допомогти їй знайти будь-який красивий підрядок заданого рядка.
#
# Вхідні дані
# Перший рядок містить одне ціле число n (3≤n≤2⋅10
# 5
#  ) — довжина рядка.
#
# Другий рядок містить один бінарний рядок — рядок, в якому Сакурако втратила свій красивий рядок.
#
# Гарантовано, що в рядку є принаймні три символи "1".
#
# Можна довести, що відповідь завжди існує.
#
# Вихідні дані
# Виведіть два цілі числа l та r (1≤l≤r≤n), де підрядок, що починається з l і закінчується в r, є красивим. Якщо є кілька рішень, виведіть будь-яке.
#
# Приклади
# Вхідні дані #1
# 5
# 10101
# Відповідь #1
# 1 4
# Вхідні дані #2
# 6
# 101101
# Відповідь #2
# 3 4
# Примітка
# У першому прикладі підрядок "1010" є красивим, оскільки довжина, яка дорівнює 4, ділиться на кількість одиниць, яка дорівнює 2.
#
# У другому прикладі підрядок "11" є красивим, оскільки довжина, яка дорівнює 2, ділиться на кількість одиниць, яка дорівнює 2.
#
# Оцінювання
# Ви отримаєте не менше 32 балів, якщо ваш розв'язок буде коректно працювати для n≤1000.

n = int(input())
a = list(map(int,input()))
l, r = 0, 0
# Формуємо масив nums, де елемент і цього мосиву - це сума всіх елементів масиву а( одиничок)
# від 0 до і включно
s=a[0] # перший елемент масиву nums
nums=[s]
for i in range(1,n):
    s+=a[i]
    nums.append(s)
# print(nums)
# перебираємо в циклі усі варіанти від 0 до i
for i in range(1,n):
    if nums[i]>=2 and (i+1)%nums[i]==0:
        l=0+1
        r=i+1
        print(l,r)
        break
# якщо в попередньому циклі ми не натрапили на потрібний варіант (l, r залишилися 0),
# тоді перевіряємо усі сусідні елементи, чи не одинички вони
if l==0 and r==0:
    for i in range(1,n-1):
        if nums[i]==nums[i-1]+1 and nums[i+1]==nums[i]+1:
            l=i+1
            r=i+2
            print(l,r)
# якщо ми ще не натрапили на потрібний варіант (l, r залишилися 0),
# тоді перебираємо в циклі усі варіанти від 1 до i, гарантовано отримаємо результат
if l==0 and r==0:
    for i in range(1,n):
        if nums[i]-nums[0]>=2 and (i)%(nums[i]-nums[0])==0:
            l=2
            r=i+1
            print(l,r)