# На екзамені з алгоритмів Петрик витягнув нещасливу задачу, тому вельми просить вашої допомоги.
# Перед вами стандартна шахова дошка 8×8, клітинки якої пронумеровані зліва направо від a до h
# та знизу вгору від 1 до 8. Серед білих фігур дошці можуть бути всі види фігур, крім короля,
# а серед чорних навпаки — є лише один король. Також відомо що фігури розставлені абсолютно довільно,
# тобто їх розміщення може не підпорядковуватись стандартним правилам шахів
# (білі навіть можуть мати забагато фігур певного типу). Вашою задачею є визначити,
# у якому положенні знаходиться чорний гравець: мат, пат чи звичайне положення.

# Довідка з шахів:
# Шах — тактичний хід, при якому проходить напад на короля суперника.
# Мат — ситуація, коли король опиняється під шахом, і у гравця нема жодного можливого ходу, після якого король перестав би перебувати під шахом.
# Пат — становище, коли сторона, котра повинна ходити, не може це зробити, бо всі її фігури позбавлені можливості зробити хід, при цьому король не перебуває під шахом.

# Правила ударів/ходів фігур в рамках задачі:
# Королева — б'є по вертикалях, діагоналях та горизонталях, на яких вона перебуває, але вона не може перескакувати через інші фігури.
# Тура — б'є по вертикалях та горизонталях, на яких вона перебуває, але не може перескакувати через інші фігури.
# Слон — б'є по діагоналях, на яких він перебуває, але не може перескакувати через інші фігури.
# Кінь — хід конем складається строго з двох пересувань: на одне поле по вертикалі чи горизонталі, потім віддаляючись від вихідного поля на одне поле по діагоналі. Це єдина фігура, яка може перескакувати через інші фігури.
# Пішак — б'є по діагоналі на одну клітинку в сторону суперника (таким чином білі пішаки завжди б'ють тільки по діагоналі вгору).
# Король — пересувається зі свого поля на одне з вільних суміжних полів (у тому числі й по діагоналі), що не перебуває під ударом фігур суперника. Може бити фігуру, яка знаходиться на суміжному полі, якщо вона не під ударом.
#
# Вхідні дані
# Вхідні дані містять 8 рядків, кожен з яких складається з 8 символів. Кожен символ задає відповідну клітинку шахової дошки:
# символ «.» позначає пусту клітинку
# символ «p» позначає пішака
# символ «r» позначає туру
# символ «n» позначає коня
# символ «b» позначає слона
# символ «Q» позначає королеву
# символ «K» позначає короля
# Гарантується, що є рівно один король.
# Вихідні дані
# У випадку мату у першому рядку виведіть «Checkmate», а в наступних рядках виведіть клітинки всіх фігур, що завдають шах у довільному порядку.
# У випадку пату у першому рядку виведіть «Stalemate».
# В іншому випадку виведіть «Continue» та у довільному порядку всі клітинки, у які король може зробити хід.
no_king = None


def pos_of_king(K, chess):
    for i in range(8):
        for j in range(8):
            if chess[i][j] == K:
                return (i, j)
    return no_king


def game():
    e = '.'
    K = 'King'
    p = 'pawn'
    r = 'rook'
    b = 'bishop'
    n = 'knight'
    chess = [[e, e, e, n, e, n, e, e, ],
             [e, e, n, e, e, n, n, e, ],
             [e, n, e, e, K, n, e, e, ],
             [e, e, n, e, e, e, n, e, ],
             [e, e, e, n, n, n, n, e, ],
             [e, e, e, e, e, e, e, e, ],
             [e, e, e, e, e, e, e, e, ],
             [e, e, e, e, e, e, e, e, ], ]

    check = []
    k_pos = pos_of_king(K, chess)
    if k_pos is no_king:
        print('Where is the King?')
        return
    for i in range(8):
        for j in range(8):
            if chess[i][j] != e:
                # pawn
                if chess[i][j] == p:
                    if k_pos[0] == i - 1 and abs(k_pos[1] - j) == 1:
                        print()
                        check.append([i, j])
                # rook
                if chess[i][j] == r:
                    if k_pos[0] == i:
                        check.append([i, j])
                        for k in range(min(k_pos[1], j) + 1, max(k_pos[1], j)):
                            if chess[i][k] != e:
                                check.pop()
                                break
                    if k_pos[1] == j:
                        check.append([i, j])
                        for k in range(min(k_pos[0], i) + 1, max(k_pos[0], i)):
                            if chess[k][j] != e:
                                check.pop()
                                break
                if chess[i][j] == b:
                    if abs(k_pos[0] - i) == abs(k_pos[1] - j):
                        check.append([i, j])
                        for k in range(1, abs(k_pos[0] - i)):
                            add_i = round(
                                k * (k_pos[0] - i) / abs(k_pos[0] - i))
                            add_j = round(
                                k * (k_pos[1] - j) / abs(k_pos[1] - j))
                            print(k, i, j)
                            print(add_i, add_j)
                            if chess[i + add_i][j + add_j] != e:
                                check.pop()
                                break
                if chess[i][j] == n:
                    if abs(k_pos[0] - i) == 1 and abs(k_pos[1] - j) == 2 or \
                       abs(k_pos[0] - i) == 2 and abs(k_pos[1] - j) == 1:
                        check.append([i, j])

    print(check)


game()
