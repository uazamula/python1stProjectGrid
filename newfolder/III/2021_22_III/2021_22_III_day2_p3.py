# C (99) Козак Вус та залізнична дорога
# Всеукраїнська олімпіада з інформатики ІІІ етап День 2 2021-2022 н.р.
# https://uoi.eolymp.space/uk/problems/99
# https://www.youtube.com/watch?v=ezG-aG44wmY -розбір
# https://archive.uoi.ua/static/uoi-3-22-tutorials.pdf - розбір

# 100%
n, k, g = map(int, input().split())
a = list(map(int, input().split()))
# масив color[i] для підрахунку ліхтарів i+1 кольору
color = [0 for i in range(k)]
for i in range(n):
    color[a[i] - 1] += 1
# print(color)
# якщо кольорів 2
if k == 2:
    # розвʼязок існує, якщо різниця дорівнює 1 і загальна кількість більше 7
    if abs(color[0] - color[1]) == 1 and n >= 7:
        # якщо можна зробити однакову кількість на гілках, тоді робимо це (x=y),
        # а інакше нехай на верхній буде на 2 більше (x-y=2)
        x = (n - 1) // 2
        y = x
        if (n + 1) % 4 != 0:
            x = (n - 1) // 2 + 1
            y = x - 2
        # виводимо кількість ліхтарів на обох гілках
        print(x, y)

        # "розставляємо" ліхтарі на залізниці, якщо першого кольору більше
        if color[0] > color[1]:
            # формуємо і друкуємо верхню гілку
            s = ''
            for i in range(x):
                s += str(i % 2 + 1)
            print(' '.join(s))
            # виводимо другий колір на вузлі
            print(2)
            # формуємо і друкуємо нижню гілку
            s = ''
            for i in range(y):
                s += str(i % 2 + 1)
            print(' '.join(s))
        # "розставляємо" ліхтарі на залізниці, якщо другого кольору більше
        if color[1] > color[0]:
            # формуємо і друкуємо верхню гілку
            s = ''
            for i in range(x):
                s += str((i + 1) % 2 + 1)
            print(' '.join(s))
            # виводимо перший колір на вузлі
            print(1)
            # формуємо і друкуємо нижню гілку
            s = ''
            for i in range(y):
                s += str((i + 1) % 2 + 1)
            print(' '.join(s))

    else:
        print(-1)

elif k > 2:
    cs = [[i + 1, color[i], ] for i in range(len(color))]
    # print(cs)
    # сортуємо кольори: з більшою частотою до меншої
    cs.sort(key=lambda x: -x[1])
    # print(cs)
    # перевіряємо умову, за якої неможливо розставити ліхтарі
    if n > 5 and (cs[0][1] > (n // 2 + n % 2)) or n == 5 and cs[0][1] > 2:
        print(-1)
    # ліхтарі можна розставити, знаходимо відповідь
    elif n == 5:
        knote = cs.pop()
        print(2, 2)
        if k == 3:
            print(cs[0][0], cs[1][0])
            print(knote[0])
            print(cs[0][0], cs[1][0])
        if k == 4:
            print(cs[0][0], cs[1][0])
            print(knote[0])
            print(cs[0][0], cs[2][0])
        if k == 5:
            print(cs[0][0], cs[1][0])
            print(knote[0])
            print(cs[2][0], cs[3][0])

    else:
        # вводимо змінні x- кількість ліхтарів на верхній гілці, y - на нижній гілці
        x, y = 0, 0
        # якщо n парне
        if n % 2 == 0:
            x, y = n // 2, n // 2 - 1
        # якщо n непарне
        if n % 2 == 1:
            # якщо однакові значення x, y непарні
            if (n // 2) % 2 == 1:
                x, y = n // 2, n // 2
                # якщо однакові значення x, y парні
            else:
                x, y = n // 2 + 1, n // 2 - 1
                # відразу обираємо вузол з найрідшим кольором
        knote = cs[-1][0]
        # і зменшуємо частоту його повторень на 1
        cs[-1][1] -= 1
        # якщо його частота зменшилася до нуля, тоді видаляємо цей колір
        if cs[-1][1] == 0:
            cs.pop()
        # беремо перший елемент масиву
        is_first = True
        # встановлюємо вказівник в позицію 0
        pos = 0
        # змінні, куди запишемо послідовність кольорів вгорі і внизу
        top = []
        bottom = ''
        start_pos = 0
        for i in range(n - 1):
            # зробимо, щоб перший колір нижньої гілки брався на початку масиву
            if i == x:
                is_first = True

                # якщо дійшли до кінця, тоді починаємо спочатку
            if pos == len(cs) - 1:
                pos = start_pos
                is_first = True
                # інакше слідкуємо, чи став наступний колір за частотою частішим
            # якщо так, тоді переходимо до нього
            elif is_first and pos + 1 < len(cs) and cs[pos + 1][1] > cs[pos][1]:
                pos += 1

            # перевіряємо, звідки беремо колір, з лівої чи правої частини масиву
            # тоді додаємо колір до масиву результату і зменшуємо кількість ліхтарів відповідного кольору
            if is_first:
                top.append(cs[pos][0])
                cs[pos][1] -= 1
            else:
                top.append(cs[-1][0])
                cs[-1][1] -= 1
            # перевіряємо, чи треба нам повертатися на початок
            if pos + 1 < len(cs) and cs[pos][1] <= cs[start_pos][1] and \
                    cs[pos + 1][1] <= cs[start_pos][1]:
                pos = start_pos
                # видаляємо колір праворуч, якщо ми його повністю вибрали
            if cs[-1][1] == 0:
                cs.pop()
            # вибрали повністю [ще один] колір зліва, зсовуємо лівий край пошуку на одиницю
            if len(cs) > 0 and start_pos < len(cs) and cs[start_pos][1] == 0:
                start_pos += 1
            # переключаємося з кінця масиву на початок і навпаки
            is_first = not is_first
            # якщо останній колір верхнього рядка збігається з кольором вузла,
            # тоді на наступному кроці будемо брати колір з початку масиву
            if not is_first and i == x - 2 and cs[-1][0] == knote:
                is_first = not is_first
                # виводимо результат для найбільшої гілки програми
        print(x, y)
        print(' '.join(map(str, top[:x])))
        print(knote)
        print(' '.join(map(str, top[x:])))

elif k == 1:
    print(-1)
