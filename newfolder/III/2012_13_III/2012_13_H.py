# H[С](16). Задача від Степана
# Всеукраїнська олімпіада з інформатики ІІІ етап Тур 2 2012-2013 н.р.
# https://drive.google.com/file/d/0BzXzAlavBkWxMi1famRXdkZTWlE/view?resourcekey=0-9tt3mjFHjgw0tOXZlYNmFA

# https://uoi.eolymp.space/uk/problems/16

# Ім’я вхідного файлу:
# Ім’я вихідного файлу:
# Обмеження по часу:
# Обмеження по пам’яті:
# task.in task.out 0,5 секунда 128 мегабайт

# Перебираючи свої дитячі іграшки,
# Степан знайшов набір із N різних прямокутників і згадав задачу,
# яку йому колись задав старенький вчитель математики.
# Назвемо прямокутник маленьким, якщо знайдеться інший прямокутник з даного набору,
# яким можна повністю накрити цей прямокутник.
# При цьому прямокутники можна повертати, але відповідні сторони мають бути паралельними.
# Наприклад, прямокутник зі сторонами 1 і 10 можна повністю накрити прямокутником 10 і 3,
# але неможна накрити прямокутником зі сторонами 9 і 9.
# Прямокутники зі сторонами 10 і 3, а також зі сторонами 9 і 9 накрити неможна,
# відповідно в наборі із цих трьох прямокутників тільки один маленький.

# Напишіть програму, яка вирішить згадану Степаном задачу –
# визначить кількість маленьких прямокутників у даному наборі.

# Формат вхідних даних: перший рядок вхідного файлу містить одне ціле число N (2 ≤ N ≤ 200000).
# У кожному з наступних N рядків міститься два цілих додатних числа –
# розміри одного прямокутника. Усі розміри не перевищують 1000000.
# Серед даних прямокутників немає однакових.

# Формат вихідних даних: вихідний файл має містити одне ціле число -
# кількість маленьких прямокутників у даному наборі.

# Приклад вхідних та вихідних даних:
# task.in
# 3
# 1 10
# 9 9
# 10 3
# task.out
# 1
# task.in
# 4
# 1 7
# 2 6
# 3 5
# 4 4
# task.out
# 0

n = int(input())  # зчитуємо кількість прямокутників
a = []  # оголошуємо масив многокутників
# зчитуємо сторони прямокутників і записуємо їх у 2d масив
# кожний елемент масива це ще один масив, елементами якого є довжини сторін
for i in range(n):
    a.append(list(map(int, input().split())))
# сортуємо масив a так, щоб друга сторона кожного прямокутника була не менша,
# ніж перша
for i in range(n):
    if a[i][0] > a[i][1]:
        a[i].sort()
# відсортований масив тепер сортуємо в порядку зростання довжини першої сторони
# за однакової довжини першої сторони сортуємо далі другу сторону за зростанням
a.sort(key=lambda x: (x[0], x[1]))

# Variant 1
# створюємо змінну, в яку будемо записувати найбільше поточне
# значення другої сторони
maxel = a[n - 1][1]
# запускаємо лічильник маленьких прямокутників
res = 0
# проходимо цикл з кінця списку, починаючи порівняння передостаннього
# елементу а з останнім
for i in range(n - 1)[::-1]:
    # умова, чи друга сторона прямокутника не більша, ніж максимальна
    if a[i][1] <= maxel:
        res += 1.  # збільшуємо лічильник на 1, якщо так
    else:
        # обираємо нове максимальне значення другої сторони, якщо ні
        maxel = a[i][1]

print(res)

# Варіант 2, більш затратний по часу і більш складний в реалізації
# b=[[a[i][1],i+1] for i in range(n)]
# b.sort(key=lambda x: (-x[0], x[1]))
#
# s=0
# k=0
# diff=0
# for i in range(0,n-1):
#     if b[i][0]>b[i+1][0] and b[i][1]>k:
#         diff=b[i][1]-k-1
#         k=b[i][1]
#         s+=diff
#
# if b[n-1][0]==b[n-2][0]and b[n-1][1]>k:
#     diff=b[n-1][1]-k-1
#     s+=diff
#
# print (s)
